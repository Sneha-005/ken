<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="0c1df5ed-10fa-4c04-84b8-78fe5e843b4f" value="{&quot;id&quot;:&quot;0c1df5ed-10fa-4c04-84b8-78fe5e843b4f&quot;,&quot;name&quot;:&quot;Implement Forced/Flexible In-App Updates with Bottom Sheet Handling&quot;,&quot;timestamp&quot;:1749866990689,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/build.gradle.kts, lines\u003dALL(1-198)\nimport org.gradle.kotlin.dsl.debug\n\nplugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.ksp)\n    alias(libs.plugins.hilt)\n    alias(libs.plugins.kotlin.serialization)\n    id(\&quot;com.google.gms.google-services\&quot;)\n//    alias(libs.plugins.room)\n}\n\nandroid {\n    namespace \u003d \&quot;com.devrachit.ken\&quot;\n    compileSdk \u003d 35\n\n    defaultConfig {\n        applicationId \u003d \&quot;com.devrachit.ken\&quot;\n        minSdk \u003d 26\n        targetSdk \u003d 35\n        versionCode \u003d 5\n        versionName \u003d \&quot;1.0.4\&quot;\n\n        testInstrumentationRunner \u003d \&quot;androidx.test.runner.AndroidJUnitRunner\&quot;\n    }\n\n    signingConfigs {\n        create(\&quot;devRelease\&quot;) {\n            storeFile \u003d file(\&quot;../keystore-dev.jks\&quot;)\n            storePassword \u003d \&quot;12345678\&quot;\n            keyAlias \u003d \&quot;key0\&quot;\n            keyPassword \u003d \&quot;12345678\&quot;\n        }\n        create(\&quot;stagingRelease\&quot;) {\n            storeFile \u003d file(\&quot;../keystore-staging.jks\&quot;)\n            storePassword \u003d \&quot;12345678\&quot;\n            keyAlias \u003d \&quot;key0\&quot;\n            keyPassword \u003d \&quot;12345678\&quot;\n        }\n        create(\&quot;prodRelease\&quot;) {\n            storeFile \u003d file(\&quot;../keystore.jks\&quot;)\n            storePassword \u003d \&quot;12345678\&quot;\n            keyAlias \u003d \&quot;key0\&quot;\n            keyPassword \u003d \&quot;12345678\&quot;\n        }\n    }\n\n    buildTypes {\n        debug {\n            signingConfig \u003d null\n        }\n        release {\n            isMinifyEnabled \u003d false\n            proguardFiles(\n                getDefaultProguardFile(\&quot;proguard-android-optimize.txt\&quot;),\n                \&quot;proguard-rules.pro\&quot;\n            )\n        }\n    }\n\n    flavorDimensions +\u003d \&quot;version\&quot;\n    productFlavors {\n        create(\&quot;dev\&quot;) {\n            dimension \u003d \&quot;version\&quot;\n            applicationIdSuffix \u003d \&quot;.dev\&quot;\n            versionNameSuffix \u003d \&quot;-dev\&quot;\n            signingConfig \u003d signingConfigs.getByName(\&quot;devRelease\&quot;)\n        }\n        create(\&quot;staging\&quot;) {\n            dimension \u003d \&quot;version\&quot;\n            applicationIdSuffix \u003d \&quot;.staging\&quot;\n            versionNameSuffix \u003d \&quot;-staging\&quot;\n            signingConfig \u003d signingConfigs.getByName(\&quot;stagingRelease\&quot;)\n        }\n        create(\&quot;prod\&quot;) {\n            dimension \u003d \&quot;version\&quot;\n            signingConfig \u003d signingConfigs.getByName(\&quot;prodRelease\&quot;)\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility \u003d JavaVersion.VERSION_11\n        targetCompatibility \u003d JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget \u003d \&quot;11\&quot;\n    }\n    buildFeatures {\n        compose \u003d true\n        viewBinding \u003d true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion \u003d libs.versions.compose.get()\n    }\n//    room {\n////        schemaDirectory(\&quot;${projectDir.absolutePath.replace(\&quot;\\\\\&quot;, \&quot;/\&quot;)}/schemas\&quot;)\n//        schemaDirectory(\&quot;${projectDir.absolutePath.replace(\&quot;\\\\\&quot;, \&quot;/\&quot;).replace(\&quot; \&quot;, \&quot;\\\\ \&quot;)}/schemas\&quot;)\n//    }\n}\n\n\ndependencies {\n\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.ui.graphics)\n    implementation(libs.androidx.ui.tooling.preview)\n    implementation(libs.androidx.material3)\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n    implementation(libs.androidx.activity.compose)\n    implementation(libs.androidx.core.ktx)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.compose.ui)\n    implementation(libs.androidx.compose.ui.graphics)\n    implementation(libs.androidx.compose.ui.tooling)\n    implementation(libs.androidx.compose.material3)\n\n    implementation(libs.androidx.compose.navigation)\n    implementation(libs.androidx.hilt.compose.navigation)\n\n    implementation(libs.hilt)\n    implementation(libs.appcompat)\n    implementation(libs.material)\n    implementation(libs.androidx.activity)\n    implementation(libs.androidx.constraintlayout)\n    implementation(libs.androidx.navigation.fragment)\n    implementation(libs.androidx.navigation.ui)\n    implementation(libs.androidx.lifecycle.runtime.compose.android)\n    ksp(libs.hilt.compiler)\n\n    implementation(libs.ktor.client.core)\n\n    implementation(libs.datastore)\n    implementation(libs.datastore.preferences)\n    implementation(libs.protobuf.javalite)\n\n    implementation(libs.coil)\n    implementation(libs.coil.gif)\n    implementation(libs.timber)\n    implementation(libs.googlePlayServiceAuth)\n\n    testImplementation(libs.junit)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n\n    androidTestImplementation(platform(libs.androidx.compose.bom))\n    androidTestImplementation(libs.androidx.ui.test.junit4)\n    debugImplementation(libs.androidx.ui.tooling)\n    debugImplementation(libs.androidx.ui.test.manifest)\n\n    implementation(libs.sdp.android)\n\n    implementation(libs.retrofit)\n    implementation(libs.okhttp)\n    implementation(libs.gson)\n    implementation(libs.scalar)\n\n    implementation(libs.androidx.compose.ui.tooling)\n    implementation(libs.androidx.credentials)\n    implementation(libs.androidx.credentials.play.services.auth)\n    implementation(libs.googleid)\n    implementation(libs.coil.compose)\n    implementation(libs.coil.svg)\n    implementation(libs.accompanist.pager.indicators)\n    implementation(libs.accompanist.pager)\n    implementation(libs.androidx.core.splashscreen)\n    implementation(libs.kotlin.serialization.json)\n    implementation(libs.shimmer)\n    implementation(libs.room.runtime)\n    implementation(libs.room.ktx)\n    ksp(libs.room.compiler)\n    implementation(libs.datastore)\n    implementation(libs.datastore.preferences)\n\n\n    // TODO: Remove these chucker dependencies\n//    implementation(\&quot;androidx.compose.material3:material3:1.2.0\&quot;)\n    debugImplementation(\&quot;com.github.chuckerteam.chucker:library:4.0.0\&quot;) // For Debug  \n    releaseImplementation(\&quot;com.github.chuckerteam.chucker:library-no-op:4.0.0\&quot;) // No-op in release\n\n    implementation(platform(\&quot;com.google.firebase:firebase-bom:33.1.0\&quot;))\n    implementation(\&quot;com.google.firebase:firebase-analytics\&quot;)\n    implementation(\&quot;com.google.firebase:firebase-config\&quot;)\n    // MPAndroidChart for graphs\n    implementation(\&quot;com.github.PhilJay:MPAndroidChart:v3.1.0\&quot;)\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nimport com.google.android.play.core.appupdate.AppUpdateManager\nimport com.google.android.play.core.appupdate.AppUpdateManagerFactory\nimport com.google.android.play.core.install.model.AppUpdateType\nimport com.google.android.play.core.install.model.UpdateAvailability\nimport com.google.android.play.core.install.InstallState\nimport com.google.android.play.core.install.InstallStateUpdatedListener\nimport android.content.IntentSender\nimport android.util.Log\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var appUpdateManager: AppUpdateManager\n    private val MY_REQUEST_CODE \u003d 100 // Request code for the update flow\n\n    // Listener for flexible updates\n    private val installStateUpdatedListener \u003d InstallStateUpdatedListener { state: InstallState -\u003e\n        if (state.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n            // After the update is downloaded, show a notification or a snackbar to user to install it\n            popupSnackbarForCompleteUpdate()\n        }\n        // You can add more states if needed, e.g., DOWNLOAD_PENDING, DOWNLOADING, FAILED, CANCELED\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        appUpdateManager \u003d AppUpdateManagerFactory.create(this)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        // For flexible updates, you must check the update status every time the app is resumed\n        // This is to handle cases where the user downloads the update but doesn\u0027t install it immediately.\n        appUpdateManager\n            .appUpdateInfo\n            .addOnSuccessListener { appUpdateInfo -\u003e\n                if (appUpdateInfo.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n                    // If an update is already downloaded but not installed, prompt the user\n                    popupSnackbarForCompleteUpdate()\n                }\n                // Optional: If an immediate update was in progress and failed/canceled, you might want to restart it\n                if (appUpdateInfo.updateAvailability() \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                    // This means an Immediate update was started previously but didn\u0027t complete.\n                    // You might want to restart the flow.\n                    try {\n                        appUpdateManager.startUpdateFlowForResult(\n                            appUpdateInfo,\n                            AppUpdateType.IMMEDIATE, // Or FLEXIBLE, depending on your initial intent\n                            this,\n                            MY_REQUEST_CODE\n                        )\n                    } catch (e: IntentSender.SendIntentException) {\n                        Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to resume in-app update flow: ${e.message}\&quot;)\n                    }\n                }\n            }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if (requestCode \u003d\u003d MY_REQUEST_CODE) {\n            when (resultCode) {\n                RESULT_OK -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow success! Result code: $resultCode\&quot;)\n                RESULT_CANCELED -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow canceled by user. Result code: $resultCode\&quot;)\n                com.google.android.play.core.install.model.ActivityResult.RESULT_IN_APP_UPDATE_FAILED -\u003e\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Update flow failed! Result code: $resultCode\&quot;)\n            }\n        }\n    }\n\n    // Don\u0027t forget to register and unregister the listener\n    override fun onStart() {\n        super.onStart()\n        appUpdateManager.registerListener(installStateUpdatedListener)\n    }\n\n    override fun onStop() {\n        super.onStop()\n        appUpdateManager.unregisterListener(installStateUpdatedListener)\n    }\n\n    // Call this method when you want to check for an update\n    fun checkForAppUpdate() {\n        // Returns an intent object that you use to check for an update.\n        appUpdateManager.appUpdateInfo.addOnSuccessListener { appUpdateInfo -\u003e\n            val updateAvailability \u003d appUpdateInfo.updateAvailability()\n            val isFlexibleUpdateAllowed \u003d appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)\n\n            if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 isFlexibleUpdateAllowed) {\n                // Request a flexible update.\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Flexible update available!\&quot;)\n                try {\n                    appUpdateManager.startUpdateFlowForResult(\n                        appUpdateInfo,\n                        AppUpdateType.FLEXIBLE, // This is what gives you the bottom sheet\n                        this,\n                        MY_REQUEST_CODE\n                    )\n                } catch (e: IntentSender.SendIntentException) {\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to start flexible in-app update flow: ${e.message}\&quot;)\n                }\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 !isFlexibleUpdateAllowed) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update available, but flexible update not allowed (e.g., only immediate allowed).\&quot;)\n                // You might decide to prompt for an Immediate update here if appropriate.\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_NOT_AVAILABLE) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;No update available.\&quot;)\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Developer-triggered update already in progress.\&quot;)\n                // You may want to resume the update flow here if it was an immediate update\n                // and you weren\u0027t handling it in onResume().\n            }\n        }.addOnFailureListener { e -\u003e\n            Log.e(\&quot;InAppUpdate\&quot;, \&quot;AppUpdateManager failed to check for update: ${e.message}\&quot;)\n        }\n    }\n\n    // A simple Snackbar to prompt the user to install the update\n    private fun popupSnackbarForCompleteUpdate() {\n        Snackbar.make(\n            findViewById(android.R.id.content), // Or your root view\n            \&quot;An update has been downloaded.\&quot;,\n            Snackbar.LENGTH_INDEFINITE\n        ).apply {\n            setAction(\&quot;RESTART\&quot;) { appUpdateManager.completeUpdate() }\n            setActionTextColor(resources.getColor(R.color.your_accent_color)) // Define a color in your colors.xml\n            show()\n        }\n    }\n}\ndependencies {\n    implementation \u0027com.google.android.play:app-update-ktx:2.1.0\u0027 // Check for the latest version!\n    // If you\u0027re not using the KTX library directly, use:\n    // implementation \u0027com.google.android.play:app-update:2.1.0\u0027\n}\nuse this to show a bottom sheet if needed \nthe logic will be \n- check the present version \n- check the minimum version \n- chec the force update field \n- if the version does match then move forward \nesle check for force update if it is true show the bottom sheet and don\u0027t allow to cancel it \n- if the force update feild is false then show the bottom sheet but allow to close that bottom sheet import com.google.android.play.core.appupdate.AppUpdateManager\nimport com.google.android.play.core.appupdate.AppUpdateManagerFactory\nimport com.google.android.play.core.install.model.AppUpdateType\nimport com.google.android.play.core.install.model.UpdateAvailability\nimport com.google.android.play.core.install.InstallState\nimport com.google.android.play.core.install.InstallStateUpdatedListener\nimport android.content.IntentSender\nimport android.util.Log\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var appUpdateManager: AppUpdateManager\n    private val MY_REQUEST_CODE \u003d 100 // Request code for the update flow\n\n    // Listener for flexible updates\n    private val installStateUpdatedListener \u003d InstallStateUpdatedListener { state: InstallState -\u003e\n        if (state.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n            // After the update is downloaded, show a notification or a snackbar to user to install it\n            popupSnackbarForCompleteUpdate()\n        }\n        // You can add more states if needed, e.g., DOWNLOAD_PENDING, DOWNLOADING, FAILED, CANCELED\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        appUpdateManager \u003d AppUpdateManagerFactory.create(this)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        // For flexible updates, you must check the update status every time the app is resumed\n        // This is to handle cases where the user downloads the update but doesn\u0027t install it immediately.\n        appUpdateManager\n            .appUpdateInfo\n            .addOnSuccessListener { appUpdateInfo -\u003e\n                if (appUpdateInfo.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n                    // If an update is already downloaded but not installed, prompt the user\n                    popupSnackbarForCompleteUpdate()\n                }\n                // Optional: If an immediate update was in progress and failed/canceled, you might want to restart it\n                if (appUpdateInfo.updateAvailability() \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                    // This means an Immediate update was started previously but didn\u0027t complete.\n                    // You might want to restart the flow.\n                    try {\n                        appUpdateManager.startUpdateFlowForResult(\n                            appUpdateInfo,\n                            AppUpdateType.IMMEDIATE, // Or FLEXIBLE, depending on your initial intent\n                            this,\n                            MY_REQUEST_CODE\n                        )\n                    } catch (e: IntentSender.SendIntentException) {\n                        Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to resume in-app update flow: ${e.message}\&quot;)\n                    }\n                }\n            }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if (requestCode \u003d\u003d MY_REQUEST_CODE) {\n            when (resultCode) {\n                RESULT_OK -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow success! Result code: $resultCode\&quot;)\n                RESULT_CANCELED -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow canceled by user. Result code: $resultCode\&quot;)\n                com.google.android.play.core.install.model.ActivityResult.RESULT_IN_APP_UPDATE_FAILED -\u003e\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Update flow failed! Result code: $resultCode\&quot;)\n            }\n        }\n    }\n\n    // Don\u0027t forget to register and unregister the listener\n    override fun onStart() {\n        super.onStart()\n        appUpdateManager.registerListener(installStateUpdatedListener)\n    }\n\n    override fun onStop() {\n        super.onStop()\n        appUpdateManager.unregisterListener(installStateUpdatedListener)\n    }\n\n    // Call this method when you want to check for an update\n    fun checkForAppUpdate() {\n        // Returns an intent object that you use to check for an update.\n        appUpdateManager.appUpdateInfo.addOnSuccessListener { appUpdateInfo -\u003e\n            val updateAvailability \u003d appUpdateInfo.updateAvailability()\n            val isFlexibleUpdateAllowed \u003d appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)\n\n            if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 isFlexibleUpdateAllowed) {\n                // Request a flexible update.\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Flexible update available!\&quot;)\n                try {\n                    appUpdateManager.startUpdateFlowForResult(\n                        appUpdateInfo,\n                        AppUpdateType.FLEXIBLE, // This is what gives you the bottom sheet\n                        this,\n                        MY_REQUEST_CODE\n                    )\n                } catch (e: IntentSender.SendIntentException) {\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to start flexible in-app update flow: ${e.message}\&quot;)\n                }\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 !isFlexibleUpdateAllowed) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update available, but flexible update not allowed (e.g., only immediate allowed).\&quot;)\n                // You might decide to prompt for an Immediate update here if appropriate.\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_NOT_AVAILABLE) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;No update available.\&quot;)\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Developer-triggered update already in progress.\&quot;)\n                // You may want to resume the update flow here if it was an immediate update\n                // and you weren\u0027t handling it in onResume().\n            }\n        }.addOnFailureListener { e -\u003e\n            Log.e(\&quot;InAppUpdate\&quot;, \&quot;AppUpdateManager failed to check for update: ${e.message}\&quot;)\n        }\n    }\n\n    // A simple Snackbar to prompt the user to install the update\n    private fun popupSnackbarForCompleteUpdate() {\n        Snackbar.make(\n            findViewById(android.R.id.content), // Or your root view\n            \&quot;An update has been downloaded.\&quot;,\n            Snackbar.LENGTH_INDEFINITE\n        ).apply {\n            setAction(\&quot;RESTART\&quot;) { appUpdateManager.completeUpdate() }\n            setActionTextColor(resources.getColor(R.color.your_accent_color)) // Define a color in your colors.xml\n            show()\n        }\n    }\n}\ndependencies {\n    implementation \u0027com.google.android.play:app-update-ktx:2.1.0\u0027 // Check for the latest version!\n    // If you\u0027re not using the KTX library directly, use:\n    // implementation \u0027com.google.android.play:app-update:2.1.0\u0027\n}\nuse this to show a bottom sheet if needed \nthe logic will be \n- check the present version \n- check the minimum version \n- chec the force update field \n- if the version does match then move forward \nesle check for force update if it is true show the bottom sheet and don\u0027t allow to cancel it \n- if the force update feild is false then show the bottom sheet but allow to close that bottom sheet\n\u003c/user_query\u003e&quot;}]}]}" />
        <entry key="1e5b1bd2-199f-4295-8bce-0b2552c2fd89" value="{&quot;id&quot;:&quot;1e5b1bd2-199f-4295-8bce-0b2552c2fd89&quot;,&quot;name&quot;:&quot;Mandatory App Update Logic with Firebase \u0026 Play Store&quot;,&quot;timestamp&quot;:1749865868888,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/devrachit/ken/presentation/screens/auth/login/LoginFragment.kt\npackage com.devrachit.ken.presentation.screens.auth.login\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Toast\nimport androidx.appcompat.app.AlertDialog\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.compose.ui.platform.ViewCompositionStrategy\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.lifecycleScope\nimport androidx.lifecycle.repeatOnLifecycle\nimport androidx.navigation.fragment.findNavController\nimport com.devrachit.ken.presentation.screens.dashboard.ActivityContent.MainActivity\nimport com.google.firebase.remoteconfig.FirebaseRemoteConfig\nimport com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.launch\nimport com.devrachit.ken.R\nimport com.devrachit.ken.utility.constants.Constants.Companion.NAVKEYUSERNAME\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.tasks.await\n\ndata class UpdateConfig(\n    val forcePlaystoreUpdate: Boolean,\n    val minimumRequiredVersion: String,\n    val playstoreUpdateMessage: String,\n    val playstoreUpdateUrl: String\n)\n\n@AndroidEntryPoint\nclass LoginFragment : Fragment() {\n\n    private val viewModel: LoginViewmodel by viewModels()\n    private lateinit var binding: View\n    private lateinit var remoteConfig: FirebaseRemoteConfig\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        val composeView \u003d ComposeView(requireContext()).apply {\n            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)\n            setContent {\n                LoginScreenPortrait()\n            }\n        }\n        binding \u003d composeView\n        initRemoteConfig()\n        return composeView\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        lifecycleScope.launch {\n            delay(1000)\n            checkForUpdates()\n            viewLifecycleOwner.repeatOnLifecycle(androidx.lifecycle.Lifecycle.State.STARTED) {\n                viewModel.navigationState.collect { navState -\u003e\n                    handleNavigation(navState)\n                }\n            }\n        }\n    }\n\n    private fun initRemoteConfig() {\n        remoteConfig \u003d FirebaseRemoteConfig.getInstance()\n        val configSettings \u003d FirebaseRemoteConfigSettings.Builder()\n            .setMinimumFetchIntervalInSeconds(1) // 1 hour\n            .build()\n        remoteConfig.setConfigSettingsAsync(configSettings)\n\n        // Set default values\n        val defaults \u003d mapOf(\n            \&quot;force_playstore_update\&quot; to false,\n            \&quot;minimum_required_version\&quot; to \&quot;1.0.0\&quot;,\n            \&quot;playstore_update_message\&quot; to \&quot;A new version is available. Please update to continue.\&quot;,\n            \&quot;playstore_update_url\&quot; to \&quot;https://play.google.com/store/apps/details?id\u003dcom.devrachit.ken\&quot;\n        )\n        remoteConfig.setDefaultsAsync(defaults)\n    }\n\n    private suspend fun checkForUpdates() {\n        try {\n            remoteConfig.fetchAndActivate().await()\n\n            val updateConfig \u003d UpdateConfig(\n                forcePlaystoreUpdate \u003d remoteConfig.getBoolean(\&quot;force_playstore_update\&quot;),\n                minimumRequiredVersion \u003d remoteConfig.getString(\&quot;minimum_required_version\&quot;),\n                playstoreUpdateMessage \u003d remoteConfig.getString(\&quot;playstore_update_message\&quot;),\n                playstoreUpdateUrl \u003d remoteConfig.getString(\&quot;playstore_update_url\&quot;)\n            )\n\n            if (isUpdateRequired(updateConfig)) {\n                showUpdateDialog(updateConfig)\n            }\n        } catch (e: Exception) {\n            // Handle error silently or log it\n        }\n    }\n\n    private fun isUpdateRequired(config: UpdateConfig): Boolean {\n        val currentVersion \u003d try {\n            requireContext().packageManager.getPackageInfo(\n                requireContext().packageName,\n                0\n            ).versionName ?: \&quot;1.0.0\&quot;\n        } catch (e: Exception) {\n            \&quot;1.0.0\&quot;\n        }\n        return compareVersions(currentVersion, config.minimumRequiredVersion) \u003c 0\n    }\n\n    private fun compareVersions(version1: String, version2: String): Int {\n        val v1Parts \u003d version1.split(\&quot;.\&quot;).map { it.toIntOrNull() ?: 0 }\n        val v2Parts \u003d version2.split(\&quot;.\&quot;).map { it.toIntOrNull() ?: 0 }\n\n        val maxLength \u003d maxOf(v1Parts.size, v2Parts.size)\n\n        for (i in 0 until maxLength) {\n            val v1Part \u003d v1Parts.getOrNull(i) ?: 0\n            val v2Part \u003d v2Parts.getOrNull(i) ?: 0\n\n            when {\n                v1Part \u003c v2Part -\u003e return -1\n                v1Part \u003e v2Part -\u003e return 1\n            }\n        }\n        return 0\n    }\n\n    private fun showUpdateDialog(config: UpdateConfig) {\n        val builder \u003d AlertDialog.Builder(requireContext())\n            .setTitle(\&quot;Update Required\&quot;)\n            .setMessage(config.playstoreUpdateMessage)\n            .setPositiveButton(\&quot;Update\&quot;) { _, _ -\u003e\n                openPlayStore(config.playstoreUpdateUrl)\n            }\n\n        if (!config.forcePlaystoreUpdate) {\n            builder.setNegativeButton(\&quot;Later\&quot;) { dialog, _ -\u003e\n                dialog.dismiss()\n            }\n        } else {\n            builder.setCancelable(false)\n        }\n\n        builder.show()\n    }\n\n    private fun openPlayStore(url: String) {\n        try {\n            val intent \u003d Intent(Intent.ACTION_VIEW, Uri.parse(url))\n            intent.setPackage(\&quot;com.android.vending\&quot;)\n            startActivity(intent)\n        } catch (e: Exception) {\n            // If Play Store app is not available, open in browser\n            val intent \u003d Intent(Intent.ACTION_VIEW, Uri.parse(url))\n            startActivity(intent)\n        }\n\n        if (remoteConfig.getBoolean(\&quot;force_playstore_update\&quot;)) {\n            requireActivity().finish()\n        }\n    }\n\n    private fun handleNavigation(navState: LoginNavigationState) {\n        when (navState) {\n            is LoginNavigationState.NavigateToMainActivity -\u003e {\n                val intent \u003d Intent(requireContext(), MainActivity::class.java)\n                intent.putExtra(NAVKEYUSERNAME, navState.username)\n                startActivity(intent)\n                requireActivity().finish()\n                requireActivity().overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)\n                viewModel.resetNavigationState()\n            }\n            is LoginNavigationState.NavigateToOnboarding -\u003e {\n                findNavController().navigate(R.id.action_loginFragment_to_onboardingFragment)\n                viewModel.resetNavigationState()\n            }\n            is LoginNavigationState.Error -\u003e {\n                Toast.makeText(requireContext(), navState.message, Toast.LENGTH_LONG).show()\n                viewModel.resetNavigationState()\n            }\n            LoginNavigationState.Idle -\u003e {\n                // Do nothing\n            }\n        }\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nimport com.google.android.play.core.appupdate.AppUpdateManager\nimport com.google.android.play.core.appupdate.AppUpdateManagerFactory\nimport com.google.android.play.core.install.model.AppUpdateType\nimport com.google.android.play.core.install.model.UpdateAvailability\nimport com.google.android.play.core.install.InstallState\nimport com.google.android.play.core.install.InstallStateUpdatedListener\nimport android.content.IntentSender\nimport android.util.Log\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var appUpdateManager: AppUpdateManager\n    private val MY_REQUEST_CODE \u003d 100 // Request code for the update flow\n\n    // Listener for flexible updates\n    private val installStateUpdatedListener \u003d InstallStateUpdatedListener { state: InstallState -\u003e\n        if (state.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n            // After the update is downloaded, show a notification or a snackbar to user to install it\n            popupSnackbarForCompleteUpdate()\n        }\n        // You can add more states if needed, e.g., DOWNLOAD_PENDING, DOWNLOADING, FAILED, CANCELED\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        appUpdateManager \u003d AppUpdateManagerFactory.create(this)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        // For flexible updates, you must check the update status every time the app is resumed\n        // This is to handle cases where the user downloads the update but doesn\u0027t install it immediately.\n        appUpdateManager\n            .appUpdateInfo\n            .addOnSuccessListener { appUpdateInfo -\u003e\n                if (appUpdateInfo.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n                    // If an update is already downloaded but not installed, prompt the user\n                    popupSnackbarForCompleteUpdate()\n                }\n                // Optional: If an immediate update was in progress and failed/canceled, you might want to restart it\n                if (appUpdateInfo.updateAvailability() \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                    // This means an Immediate update was started previously but didn\u0027t complete.\n                    // You might want to restart the flow.\n                    try {\n                        appUpdateManager.startUpdateFlowForResult(\n                            appUpdateInfo,\n                            AppUpdateType.IMMEDIATE, // Or FLEXIBLE, depending on your initial intent\n                            this,\n                            MY_REQUEST_CODE\n                        )\n                    } catch (e: IntentSender.SendIntentException) {\n                        Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to resume in-app update flow: ${e.message}\&quot;)\n                    }\n                }\n            }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if (requestCode \u003d\u003d MY_REQUEST_CODE) {\n            when (resultCode) {\n                RESULT_OK -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow success! Result code: $resultCode\&quot;)\n                RESULT_CANCELED -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow canceled by user. Result code: $resultCode\&quot;)\n                com.google.android.play.core.install.model.ActivityResult.RESULT_IN_APP_UPDATE_FAILED -\u003e\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Update flow failed! Result code: $resultCode\&quot;)\n            }\n        }\n    }\n\n    // Don\u0027t forget to register and unregister the listener\n    override fun onStart() {\n        super.onStart()\n        appUpdateManager.registerListener(installStateUpdatedListener)\n    }\n\n    override fun onStop() {\n        super.onStop()\n        appUpdateManager.unregisterListener(installStateUpdatedListener)\n    }\n\n    // Call this method when you want to check for an update\n    fun checkForAppUpdate() {\n        // Returns an intent object that you use to check for an update.\n        appUpdateManager.appUpdateInfo.addOnSuccessListener { appUpdateInfo -\u003e\n            val updateAvailability \u003d appUpdateInfo.updateAvailability()\n            val isFlexibleUpdateAllowed \u003d appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)\n\n            if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 isFlexibleUpdateAllowed) {\n                // Request a flexible update.\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Flexible update available!\&quot;)\n                try {\n                    appUpdateManager.startUpdateFlowForResult(\n                        appUpdateInfo,\n                        AppUpdateType.FLEXIBLE, // This is what gives you the bottom sheet\n                        this,\n                        MY_REQUEST_CODE\n                    )\n                } catch (e: IntentSender.SendIntentException) {\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to start flexible in-app update flow: ${e.message}\&quot;)\n                }\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 !isFlexibleUpdateAllowed) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update available, but flexible update not allowed (e.g., only immediate allowed).\&quot;)\n                // You might decide to prompt for an Immediate update here if appropriate.\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_NOT_AVAILABLE) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;No update available.\&quot;)\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Developer-triggered update already in progress.\&quot;)\n                // You may want to resume the update flow here if it was an immediate update\n                // and you weren\u0027t handling it in onResume().\n            }\n        }.addOnFailureListener { e -\u003e\n            Log.e(\&quot;InAppUpdate\&quot;, \&quot;AppUpdateManager failed to check for update: ${e.message}\&quot;)\n        }\n    }\n\n    // A simple Snackbar to prompt the user to install the update\n    private fun popupSnackbarForCompleteUpdate() {\n        Snackbar.make(\n            findViewById(android.R.id.content), // Or your root view\n            \&quot;An update has been downloaded.\&quot;,\n            Snackbar.LENGTH_INDEFINITE\n        ).apply {\n            setAction(\&quot;RESTART\&quot;) { appUpdateManager.completeUpdate() }\n            setActionTextColor(resources.getColor(R.color.your_accent_color)) // Define a color in your colors.xml\n            show()\n        }\n    }\n}\ndependencies {\n    implementation \u0027com.google.android.play:app-update-ktx:2.1.0\u0027 // Check for the latest version!\n    // If you\u0027re not using the KTX library directly, use:\n    // implementation \u0027com.google.android.play:app-update:2.1.0\u0027\n}\nuse this to show a bottom sheet if needed \nthe logic will be \n- check the present version \n- check the minimum version \n- chec the force update field \n- if the version does match then move forward \nesle check for force update if it is true show the bottom sheet and don\u0027t allow to cancel it \n- if the force update feild is false then show the bottom sheet but allow to close that bottom sheet\n\u003c/user_query\u003e&quot;}]}]}" />
        <entry key="2924b549-7a8b-467e-ad84-c64bd1ad1346" value="{&quot;id&quot;:&quot;2924b549-7a8b-467e-ad84-c64bd1ad1346&quot;,&quot;name&quot;:&quot;...&quot;,&quot;timestamp&quot;:1749865885315,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```kotlin:app/src/main/java/com/devrachit/ken/presentation/screens/auth/login/LoginFragment.kt\npackage com.devrachit.ken.presentation.screens.auth.login\n\nimport android.content.Intent\nimport android.net.Uri\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.Toast\nimport androidx.appcompat.app.AlertDialog\nimport androidx.compose.ui.platform.ComposeView\nimport androidx.compose.ui.platform.ViewCompositionStrategy\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.lifecycleScope\nimport androidx.lifecycle.repeatOnLifecycle\nimport androidx.navigation.fragment.findNavController\nimport com.devrachit.ken.presentation.screens.dashboard.ActivityContent.MainActivity\nimport com.google.firebase.remoteconfig.FirebaseRemoteConfig\nimport com.google.firebase.remoteconfig.FirebaseRemoteConfigSettings\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.launch\nimport com.devrachit.ken.R\nimport com.devrachit.ken.utility.constants.Constants.Companion.NAVKEYUSERNAME\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.tasks.await\n\ndata class UpdateConfig(\n    val forcePlaystoreUpdate: Boolean,\n    val minimumRequiredVersion: String,\n    val playstoreUpdateMessage: String,\n    val playstoreUpdateUrl: String\n)\n\n@AndroidEntryPoint\nclass LoginFragment : Fragment() {\n\n    private val viewModel: LoginViewmodel by viewModels()\n    private lateinit var binding: View\n    private lateinit var remoteConfig: FirebaseRemoteConfig\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        val composeView \u003d ComposeView(requireContext()).apply {\n            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)\n            setContent {\n                LoginScreenPortrait()\n            }\n        }\n        binding \u003d composeView\n        initRemoteConfig()\n        return composeView\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        lifecycleScope.launch {\n            delay(1000)\n            checkForUpdates()\n            viewLifecycleOwner.repeatOnLifecycle(androidx.lifecycle.Lifecycle.State.STARTED) {\n                viewModel.navigationState.collect { navState -\u003e\n                    handleNavigation(navState)\n                }\n            }\n        }\n    }\n\n    private fun initRemoteConfig() {\n        remoteConfig \u003d FirebaseRemoteConfig.getInstance()\n        val configSettings \u003d FirebaseRemoteConfigSettings.Builder()\n            .setMinimumFetchIntervalInSeconds(1) // 1 hour\n            .build()\n        remoteConfig.setConfigSettingsAsync(configSettings)\n\n        // Set default values\n        val defaults \u003d mapOf(\n            \&quot;force_playstore_update\&quot; to false,\n            \&quot;minimum_required_version\&quot; to \&quot;1.0.0\&quot;,\n            \&quot;playstore_update_message\&quot; to \&quot;A new version is available. Please update to continue.\&quot;,\n            \&quot;playstore_update_url\&quot; to \&quot;https://play.google.com/store/apps/details?id\u003dcom.devrachit.ken\&quot;\n        )\n        remoteConfig.setDefaultsAsync(defaults)\n    }\n\n    private suspend fun checkForUpdates() {\n        try {\n            remoteConfig.fetchAndActivate().await()\n\n            val updateConfig \u003d UpdateConfig(\n                forcePlaystoreUpdate \u003d remoteConfig.getBoolean(\&quot;force_playstore_update\&quot;),\n                minimumRequiredVersion \u003d remoteConfig.getString(\&quot;minimum_required_version\&quot;),\n                playstoreUpdateMessage \u003d remoteConfig.getString(\&quot;playstore_update_message\&quot;),\n                playstoreUpdateUrl \u003d remoteConfig.getString(\&quot;playstore_update_url\&quot;)\n            )\n\n            if (isUpdateRequired(updateConfig)) {\n                showUpdateDialog(updateConfig)\n            }\n        } catch (e: Exception) {\n            // Handle error silently or log it\n        }\n    }\n\n    private fun isUpdateRequired(config: UpdateConfig): Boolean {\n        val currentVersion \u003d try {\n            requireContext().packageManager.getPackageInfo(\n                requireContext().packageName,\n                0\n            ).versionName ?: \&quot;1.0.0\&quot;\n        } catch (e: Exception) {\n            \&quot;1.0.0\&quot;\n        }\n        return compareVersions(currentVersion, config.minimumRequiredVersion) \u003c 0\n    }\n\n    private fun compareVersions(version1: String, version2: String): Int {\n        val v1Parts \u003d version1.split(\&quot;.\&quot;).map { it.toIntOrNull() ?: 0 }\n        val v2Parts \u003d version2.split(\&quot;.\&quot;).map { it.toIntOrNull() ?: 0 }\n\n        val maxLength \u003d maxOf(v1Parts.size, v2Parts.size)\n\n        for (i in 0 until maxLength) {\n            val v1Part \u003d v1Parts.getOrNull(i) ?: 0\n            val v2Part \u003d v2Parts.getOrNull(i) ?: 0\n\n            when {\n                v1Part \u003c v2Part -\u003e return -1\n                v1Part \u003e v2Part -\u003e return 1\n            }\n        }\n        return 0\n    }\n\n    private fun showUpdateDialog(config: UpdateConfig) {\n        val builder \u003d AlertDialog.Builder(requireContext())\n            .setTitle(\&quot;Update Required\&quot;)\n            .setMessage(config.playstoreUpdateMessage)\n            .setPositiveButton(\&quot;Update\&quot;) { _, _ -\u003e\n                openPlayStore(config.playstoreUpdateUrl)\n            }\n\n        if (!config.forcePlaystoreUpdate) {\n            builder.setNegativeButton(\&quot;Later\&quot;) { dialog, _ -\u003e\n                dialog.dismiss()\n            }\n        } else {\n            builder.setCancelable(false)\n        }\n\n        builder.show()\n    }\n\n    private fun openPlayStore(url: String) {\n        try {\n            val intent \u003d Intent(Intent.ACTION_VIEW, Uri.parse(url))\n            intent.setPackage(\&quot;com.android.vending\&quot;)\n            startActivity(intent)\n        } catch (e: Exception) {\n            // If Play Store app is not available, open in browser\n            val intent \u003d Intent(Intent.ACTION_VIEW, Uri.parse(url))\n            startActivity(intent)\n        }\n\n        if (remoteConfig.getBoolean(\&quot;force_playstore_update\&quot;)) {\n            requireActivity().finish()\n        }\n    }\n\n    private fun handleNavigation(navState: LoginNavigationState) {\n        when (navState) {\n            is LoginNavigationState.NavigateToMainActivity -\u003e {\n                val intent \u003d Intent(requireContext(), MainActivity::class.java)\n                intent.putExtra(NAVKEYUSERNAME, navState.username)\n                startActivity(intent)\n                requireActivity().finish()\n                requireActivity().overridePendingTransition(R.anim.slide_in_right, R.anim.slide_out_left)\n                viewModel.resetNavigationState()\n            }\n            is LoginNavigationState.NavigateToOnboarding -\u003e {\n                findNavController().navigate(R.id.action_loginFragment_to_onboardingFragment)\n                viewModel.resetNavigationState()\n            }\n            is LoginNavigationState.Error -\u003e {\n                Toast.makeText(requireContext(), navState.message, Toast.LENGTH_LONG).show()\n                viewModel.resetNavigationState()\n            }\n            LoginNavigationState.Idle -\u003e {\n                // Do nothing\n            }\n        }\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\nimport com.google.android.play.core.appupdate.AppUpdateManager\nimport com.google.android.play.core.appupdate.AppUpdateManagerFactory\nimport com.google.android.play.core.install.model.AppUpdateType\nimport com.google.android.play.core.install.model.UpdateAvailability\nimport com.google.android.play.core.install.InstallState\nimport com.google.android.play.core.install.InstallStateUpdatedListener\nimport android.content.IntentSender\nimport android.util.Log\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var appUpdateManager: AppUpdateManager\n    private val MY_REQUEST_CODE \u003d 100 // Request code for the update flow\n\n    // Listener for flexible updates\n    private val installStateUpdatedListener \u003d InstallStateUpdatedListener { state: InstallState -\u003e\n        if (state.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n            // After the update is downloaded, show a notification or a snackbar to user to install it\n            popupSnackbarForCompleteUpdate()\n        }\n        // You can add more states if needed, e.g., DOWNLOAD_PENDING, DOWNLOADING, FAILED, CANCELED\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n\n        appUpdateManager \u003d AppUpdateManagerFactory.create(this)\n    }\n\n    override fun onResume() {\n        super.onResume()\n        // For flexible updates, you must check the update status every time the app is resumed\n        // This is to handle cases where the user downloads the update but doesn\u0027t install it immediately.\n        appUpdateManager\n            .appUpdateInfo\n            .addOnSuccessListener { appUpdateInfo -\u003e\n                if (appUpdateInfo.installStatus() \u003d\u003d com.google.android.play.core.install.model.InstallStatus.DOWNLOADED) {\n                    // If an update is already downloaded but not installed, prompt the user\n                    popupSnackbarForCompleteUpdate()\n                }\n                // Optional: If an immediate update was in progress and failed/canceled, you might want to restart it\n                if (appUpdateInfo.updateAvailability() \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                    // This means an Immediate update was started previously but didn\u0027t complete.\n                    // You might want to restart the flow.\n                    try {\n                        appUpdateManager.startUpdateFlowForResult(\n                            appUpdateInfo,\n                            AppUpdateType.IMMEDIATE, // Or FLEXIBLE, depending on your initial intent\n                            this,\n                            MY_REQUEST_CODE\n                        )\n                    } catch (e: IntentSender.SendIntentException) {\n                        Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to resume in-app update flow: ${e.message}\&quot;)\n                    }\n                }\n            }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        if (requestCode \u003d\u003d MY_REQUEST_CODE) {\n            when (resultCode) {\n                RESULT_OK -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow success! Result code: $resultCode\&quot;)\n                RESULT_CANCELED -\u003e Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update flow canceled by user. Result code: $resultCode\&quot;)\n                com.google.android.play.core.install.model.ActivityResult.RESULT_IN_APP_UPDATE_FAILED -\u003e\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Update flow failed! Result code: $resultCode\&quot;)\n            }\n        }\n    }\n\n    // Don\u0027t forget to register and unregister the listener\n    override fun onStart() {\n        super.onStart()\n        appUpdateManager.registerListener(installStateUpdatedListener)\n    }\n\n    override fun onStop() {\n        super.onStop()\n        appUpdateManager.unregisterListener(installStateUpdatedListener)\n    }\n\n    // Call this method when you want to check for an update\n    fun checkForAppUpdate() {\n        // Returns an intent object that you use to check for an update.\n        appUpdateManager.appUpdateInfo.addOnSuccessListener { appUpdateInfo -\u003e\n            val updateAvailability \u003d appUpdateInfo.updateAvailability()\n            val isFlexibleUpdateAllowed \u003d appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.FLEXIBLE)\n\n            if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 isFlexibleUpdateAllowed) {\n                // Request a flexible update.\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Flexible update available!\&quot;)\n                try {\n                    appUpdateManager.startUpdateFlowForResult(\n                        appUpdateInfo,\n                        AppUpdateType.FLEXIBLE, // This is what gives you the bottom sheet\n                        this,\n                        MY_REQUEST_CODE\n                    )\n                } catch (e: IntentSender.SendIntentException) {\n                    Log.e(\&quot;InAppUpdate\&quot;, \&quot;Failed to start flexible in-app update flow: ${e.message}\&quot;)\n                }\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_AVAILABLE \u0026\u0026 !isFlexibleUpdateAllowed) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Update available, but flexible update not allowed (e.g., only immediate allowed).\&quot;)\n                // You might decide to prompt for an Immediate update here if appropriate.\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.UPDATE_NOT_AVAILABLE) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;No update available.\&quot;)\n            } else if (updateAvailability \u003d\u003d UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                Log.d(\&quot;InAppUpdate\&quot;, \&quot;Developer-triggered update already in progress.\&quot;)\n                // You may want to resume the update flow here if it was an immediate update\n                // and you weren\u0027t handling it in onResume().\n            }\n        }.addOnFailureListener { e -\u003e\n            Log.e(\&quot;InAppUpdate\&quot;, \&quot;AppUpdateManager failed to check for update: ${e.message}\&quot;)\n        }\n    }\n\n    // A simple Snackbar to prompt the user to install the update\n    private fun popupSnackbarForCompleteUpdate() {\n        Snackbar.make(\n            findViewById(android.R.id.content), // Or your root view\n            \&quot;An update has been downloaded.\&quot;,\n            Snackbar.LENGTH_INDEFINITE\n        ).apply {\n            setAction(\&quot;RESTART\&quot;) { appUpdateManager.completeUpdate() }\n            setActionTextColor(resources.getColor(R.color.your_accent_color)) // Define a color in your colors.xml\n            show()\n        }\n    }\n}\ndependencies {\n    implementation \u0027com.google.android.play:app-update-ktx:2.1.0\u0027 // Check for the latest version!\n    // If you\u0027re not using the KTX library directly, use:\n    // implementation \u0027com.google.android.play:app-update:2.1.0\u0027\n}\nuse this to show a bottom sheet if needed \nthe logic will be \n- check the present version \n- check the minimum version \n- chec the force update field \n- if the version does match then move forward \nesle check for force update if it is true show the bottom sheet and don\u0027t allow to cancel it \n- if the force update feild is false then show the bottom sheet but allow to close that bottom sheet\n\u003c/user_query\u003e&quot;}]}]}" />
      </map>
    </option>
  </component>
</project>